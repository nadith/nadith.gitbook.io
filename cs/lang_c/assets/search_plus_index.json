{"/cs/lang_c/pages/01_about/": {
    "title": "About Us",
    "keywords": "wiki",
    "url": "/cs/lang_c/pages/01_about/",
    "body": "At Intelligent Mind Labs (imindlabs), we specialize in utilizing artificial intelligence (AI) to revolutionize enterprise solutions. Our expertise lies in harnessing the capabilities of AI to reshape and enhance different facets of business operations. We aim to articulate our vision and mission for the wiki as follows: Our Vision Empower People with Knowledge Welcome to our website, where the realms of Data Science, Computing, Software Development, and Mathematics converge to empower individuals with advanced knowledge and practical insights. In an era dominated by Artificial Intelligence, we firmly believe that sharing knowledge is not just beneficial but imperative for progress. Our mission is rooted in the conviction that access to advanced knowledge should be universal and unrestricted. We are committed to providing a platform where anyone, regardless of background or resources, can delve into the intricacies of these disciplines without barriers. We firmly stand by the principle that knowledge should be free, enabling individuals from all walks of life to unlock their potential and contribute meaningfully to society. At the heart of our endeavor lies community building. We understand that the collective intelligence and diverse perspectives of a community are essential for driving innovation and fostering a better future. Through collaboration and knowledge exchange, we aim to cultivate a vibrant community of learners, practitioners, and enthusiasts who are passionate about leveraging technology and mathematics for positive change. Education is the cornerstone of societal advancement. We believe that by democratizing access to high-quality educational resources, we can nurture a more informed, skilled, and empowered society. Our commitment to excellence in education is reflected in the comprehensive wikis and resources we offer, meticulously curated to cater to learners at every stage of their journey. Join us in our mission to harness the power of knowledge for the betterment of society. Together, let’s pave the way for a future where education knows no bounds, and every individual has the opportunity to thrive and contribute to a brighter tomorrow. Our Mission Our mission is to democratize access to advanced knowledge in Data Science, Computing, Software Development, and Mathematics, fostering a community-driven platform where individuals from all backgrounds can freely explore and engage with these disciplines. We believe that in an era dominated by Artificial Intelligence, sharing knowledge is essential for societal progress. Rooted in the belief that knowledge should be universally accessible, we are committed to breaking down barriers to education. By providing a free and open platform, we empower individuals to unlock their potential and contribute meaningfully to society. At the core of our mission lies community building. We recognize the value of collective intelligence and diverse perspectives in driving innovation and shaping a better future. Through collaboration and knowledge exchange, we strive to cultivate a vibrant community of learners, practitioners, and enthusiasts passionate about leveraging technology and mathematics for positive change. Education is the cornerstone of societal advancement, and we are dedicated to excellence in this endeavor. By curating comprehensive wikis and resources, we aim to equip individuals at every stage of their learning journey with the tools and insights they need to succeed. Together, we’re building a more informed, skilled, and empowered society. Who are we ? We are a vibrant community, where a diverse array of industry professionals, experts, and enthusiasts converge to share their wealth of knowledge and expertise in Data Science, Mathematics, Computing, Software Development, and Artificial Intelligence. Behind every contribution on our platform lies a passionate individual with years of experience and deep-rooted expertise in their respective fields. From seasoned professionals to emerging talents, our contributors hail from various industries, bringing with them a wealth of practical insights and real-world experience. Our platform serves as a hub where individuals can access a comprehensive repository of resources to excel in their journey through the realms of Data Science, Mathematics, Computing, Software Development, and AI. Whether you’re a novice seeking to grasp the fundamentals or a seasoned practitioner looking to stay abreast of the latest advancements, our community-driven wikis provide a wealth of information tailored to meet your needs. We take pride in the caliber of our contributors, whose dedication to knowledge sharing and community building is the driving force behind our platform’s success. By harnessing the collective wisdom and expertise of our contributors, we aim to empower learners and professionals alike to unlock their full potential and thrive in an ever-evolving digital landscape. Here, we extend our gratitude and recognition to the founders and top contributors who have played pivotal roles in shaping our wiki community."
  },"/cs/lang_c/pages/02_whats_next/": {
    "title": "Whats Next",
    "keywords": "wiki",
    "url": "/cs/lang_c/pages/02_whats_next/",
    "body": "Our extensive library of wikis covers a broad spectrum of disciplines, catering to diverse interests and fields of expertise. From Computer Science to Data Science, Mathematics to Engineering, Software Development to Cloud Computing, and beyond, our comprehensive collection provides valuable insights and resources for learners and professionals alike. No matter your area of interest or expertise, our diverse wiki library is here to support your learning journey and help you stay ahead in today’s rapidly evolving technological landscape. Dive in and explore the wealth of knowledge at your fingertips. Explore the full list of our wiki library below to discover the wealth of knowledge waiting to be uncovered: Data Science Machine Learning Advanced Machine Learning"
  },"/cs/lang_c/wiki/2019-04-27-adv-c.html": {
    "title": "08 Advance C",
    "keywords": "wiki",
    "url": "/cs/lang_c/wiki/2019-04-27-adv-c.html",
    "body": ""
  },"/cs/lang_c/wiki/2019-04-27-gdb.html": {
    "title": "07 Testing and Debugging",
    "keywords": "wiki",
    "url": "/cs/lang_c/wiki/2019-04-27-gdb.html",
    "body": ""
  },"/cs/lang_c/wiki/2019-04-27-struct.html": {
    "title": "06 Structures",
    "keywords": "wiki",
    "url": "/cs/lang_c/wiki/2019-04-27-struct.html",
    "body": ""
  },"/cs/lang_c/wiki/2019-04-27-io.html": {
    "title": "05 Input/Output",
    "keywords": "wiki",
    "url": "/cs/lang_c/wiki/2019-04-27-io.html",
    "body": ""
  },"/cs/lang_c/wiki/2019-04-27-arrays.html": {
    "title": "04 Arrays",
    "keywords": "wiki",
    "url": "/cs/lang_c/wiki/2019-04-27-arrays.html",
    "body": ""
  },"/cs/lang_c/wiki/2019-04-27-pointers.html": {
    "title": "03 Pointers",
    "keywords": "wiki",
    "url": "/cs/lang_c/wiki/2019-04-27-pointers.html",
    "body": "#include &lt;stdio&gt; int main() { printf(\"Hello, World!\\n\"); return 0; }"
  },"/cs/lang_c/wiki/2019-04-27-pre-processing.html": {
    "title": "02 Preprocessing",
    "keywords": "wiki",
    "url": "/cs/lang_c/wiki/2019-04-27-pre-processing.html",
    "body": "FAQ “Makefile:2: * missing separator. Stop” I keep getting this error when trying to run my makefile. I have used a single TAB on the line after the target file. Changed the ~/.vimrc settings back to standard to see if that would work but still nothing. Note: This issue happened to a student who used VIM text editor. The most likely reasoning is because the .vimrc (VIM configuration file) does not put an exception for a makefile. Please make sure you have the following command at the end of the .vimrc file: autocmd FileType make setlocal noexpandtab Explanation: Makefile needs to use a single TAB space (not 2 or more) for indentation. If the text editor automatically converts any TAB key as multiple space keys, the makefile will not work. If you use VScode, you can specify that you are writing a makefile when you start a new file. In that case, VScode will automatically use the correct setting for it. Is there a quick and easy way to compile all the .c files, generate executable and run the executable? Is a easy and quick way to compile all .c files, generate the executable and run the code at once? Otherwise, I will have to compile each .c file seperate to .o files and then link them together to create the executable and then run it via a makefile We always recommend you to make the make file since it efficiently handles the compilation process (it only compile the files which are modified). But lets say, you just want to compile a set of .c files as fast as you can to test some sample codes you have written. Then see below: gcc -Wall -ansi -pedantic *.c -o prog &amp;&amp; ./prog In linux, you can combine two commands using &amp;&amp; gcc -Wall -ansi -pedantic *.c -c &amp;&amp; gcc *.o -o prog &amp;&amp; ./prog Do we have bool data type or bool literals in C? C does not have a boolean literal (True, False) or boolean type (bool). Hence, 0 or NULL is interpreted as False, while any non-zero value is interpreted as True. Note: NULL is a #define for (void*) 0 in the compiler dependant header (stddef.h) Usually, we #define 0 to be FALSE and 1 to be TRUE as below: #define FALSE 0 #define TRUE 1 /* or */ #define FALSE 0 #define TRUE !FALSE /* !FALSE =&gt; !0 =&gt; 1 */ The reason why we usually don’t #define any random non-zero value to be TRUE is because, when negation ! operator is used on 0 it returns 1 and vice-versa, thereby maintaining the mathematical property of boolean values TRUE == !FALSE The following examples demonstrate how C interpret boolean values with integer literals: #include &lt;stdio.h&gt; #define TRUE 1 #define FALSE !TRUE int main() { /* Following examples are purely for your knowledge. Refer to the top of this file for the recommended way to define TRUE and FALSE */ /* NOT TODO: Do not do the following to interpret true and false in C. These examples are purely for the understanding of the concept */ /* C does not have boolean datatype or boolean literals (True, False) */ /* Any non-zero used at a place where a condition is expected, will be treated as true in C */ if (1000) { printf(\"Non-zero value in the place of the condition will be interpreted as true\\n\"); } if (0) /* The value 0 or NULL will be interpreted as false */ { } else { printf(\"Zero or NULL in the place of the condition will be interpreted as false\\n\"); } /* Logical operator ! (not) following a non-zero value, will result in 0 which is then be interpreted as false */ if (!1000) { } else { printf(\"!(any non-zero value) =&gt; 0\\n\"); } /* Logical operator ! (not) following a zero value or NULL, will result in 1 which is then be interpreted as true */ if (!0) /* or (!NULL) */ { printf(\"!(zero or NULL) =&gt; 1\\n\"); } else { } /* Checkout the following printf to verify the concepts above */ printf(\"Boolean TRUE, FALSE: %d, %d\\n\", TRUE, FALSE); printf(\"Interpreted true: %d, %d, %d\\n\", 10, (!(!10)), !NULL); printf(\"Interpreted false: %d, %ld\\n\", !10, (long int)NULL); return 0; } Can I pass an integer to a function that expects a char type parameter or vice-versa? Yes, you can. But remember char has only 8 bits (platform dependant). Therefore you can only store numbers from (-128) to 127 (\\(-2^7\\) to \\((2^7) - 1\\)). The signed data types such as (char, int) utilize the 1st bit to indicate the sign of the number. You will learn the representation of signed variables and unsigned variables and the effect of bit-shifting on them in “Misc C” Lecture. char ch; ch = 'A'; /* All good. 'A' is a char literal */ ch = 65; /* All good. 65 is a integer literal */ ch = \"A\"; /* ERROR: \"A\" is a string literal */ Furthermore, since computers cannot understand characters ‘A’, ‘B’, etc, but numbers (in binary) every character on the keyboard corresponds to a special code called “ASCII code” (or Unicode - the extended version of ASCII). Therefore if you assign a char literal to an integer variable, it means you are assigning the corresponding ASCII value of it. Please refer to the ASCII code table here. int num = 'A'; /* num will be 65 */ char ch = 'A'; /* ch will be 65 */ printf(\"%d\", num); /* prints 65 */ printf(\"%d\", ch); /* prints 65 */ printf(\"%c\", num); /* prints 'A' */ printf(\"%c\", ch); /* prints 'A' */ /* char simply means an allocation of 8 bits (platform dependant) whereas int simply means an allocation of 32 bits (platform dependant) */ Basically, invoking functions with char type parameters by passing an integer literal or vice versa follow the same concepts explained above. #include &lt;stdio.h&gt; void fCh(char ch) { printf(\"%d\", ch); /* prints the numerical value of ch */ printf(\"%c\", ch); /* prints the character corresponds to the value of ch using ASCII conversion table */ } void fInt(int num) { printf(\"%d\", num); /* prints the numerical value of num */ printf(\"%c\", num); /* prints the character corresponds to num in relation to the ASCII table */ } int main() { fCh('A'); fCh(65); fInt('A'); fInt(65); return 0; }"
  },"/cs/lang_c/basics/2019-04-27-c-basics.html": {
    "title": "01 C Basics",
    "keywords": "basics",
    "url": "/cs/lang_c/basics/2019-04-27-c-basics.html",
    "body": "Welcome to our Data Science Wiki, your ultimate resource for delving into the intricate world of machine learning, advanced machine learning, deep learning, numerical optimization, and advance optimization techniques, and the mathematics that underpin these fields. Our wiki is a comprehensive repository of knowledge, meticulously curated to provide insights, techniques, and resources for learners and practitioners alike. Hello World in C 1. Create a New Source File: Open a text editor or an integrated development environment (IDE) like Visual Studio Code, Atom, Sublime Text, or any other of your choice. Create a new file and save it with a .c extension. For example, you could name it hello_world.c #include &lt;stdio&gt; int main() { printf(\"Hello, World!\\n\"); return 0; } 2. In the newly created file, write the above C code: This code includes the standard input-output header file &lt;stdio.h&gt; which provides the printf function for printing text to the console. The main() function is the entry point of the program. It’s where the execution of the program begins. Inside main(), printf(\"Hello, World!\\n\"); prints “Hello, World!” to the console followed by a newline character \\n. return 0; indicates successful completion of the program. 3. Compile the Program: Open a terminal or command prompt. Navigate to the directory where your .c file is located. Compile the program using a C compiler such as gcc (GNU Compiler Collection). gcc -o hello_world hello_world.c This command tells the compiler (gcc) to compile the source file hello_world.c and generate an executable file named hello_world. 4. Run the Program: After successful compilation, you’ll have an executable file named hello_world (or whatever name you specified with the -o option). Execute the program by typing its name in the terminal and pressing Enter: ./hello_world You should see the output: Hello, World! Congratulations! You’ve successfully created and executed a “Hello, World!” program in C! C89 vs C99 Standards C89 and C99 refer to different standards of the C programming language, released by the International Organization for Standardization (ISO). Here are the key differences between them: 1. Release Year: C89 (also known as ANSI C or ISO C90): Released in 1989. C99: Released in 1999. 2. Feature Set: C89: It introduced the basic features of the C language, including functions, loops, conditionals, data types, and standard libraries like stdio.h and stdlib.h. C99: It introduced several new features and improvements over C89, such as: – New data types like long long int and bool. – Inline functions. – Variable-length arrays. – Support for one-line comments beginning with //. – New standard library functions like stdint.h, tgmath.h, and stdbool.h. – More flexible declarations, including mixing variable declarations with statements. 3. Complex Numbers: C99 introduced native support for complex numbers and associated mathematical functions through the complex.h header. 4. Designated Initializers: C99 introduced designated initializers, allowing elements of structures and arrays to be initialized by specifying their indices or field names. 5. Flexible Array Members: C99 allows the last member of a structure to be an array of unspecified size, known as a flexible array member. Variable Declarations: C99 allows variable declarations to appear anywhere in a block, whereas C89 requires them to appear only at the beginning of a block. 6. Standardization of Certain Previously Common Extensions: C99 standardized certain features that were previously common extensions in various C compilers, such as inline functions and variable-length arrays. 7. Compatibility: While C99 introduced significant improvements, it also maintained a high level of compatibility with C89. Most valid C89 code should also be valid under C99, though some older compilers may not fully support C99 features. C99 introduced several new features and improvements over C89, making it a more versatile and expressive language. However, due to the existing codebase and compatibility concerns, adoption of C99 features might vary depending on the specific project and toolchain requirements. GCC Flags gcc -Wall -ansi -pedantic -Werror -Wall = show all warnings -ansi -pedantic = ensures the code is C89 compliant -Werror = treat all warnings as errors! -Werror flag is optional and you may avoid using it since you are expected to know the difference between hardline errors and warnings. If you use -Werror flag, you will not see any warnings since all warnings will be treated as errors. Btw, make sure you fix all your warnings, errors in the code during assignment submissions. Type of Errors Compile-time Errors/Warnings (syntax errors, etc. detectable during compile-time) Runtime Errors (runtime-errors but exceptions) Logical Errors (runtime-errors, but wrong logic) Compile-time Errors/Warnings During compilation you may encounter: Errors: Remember errors are hardline bugs in your code (i.e. syntax errors) and you will not be able to successfully compile the code with errors. The executable file (output file) will not be created. Warnings: These are soft errors but not bugs. They have the potential to introduce runtime issues (runtime exceptions and logical bugs). Also, fixing the warnings will help you to improve the readability and the maintainability of the code. i.e. int main() { int num = 1; /* WARNING: unused variable */ return 0; } /* It is always the best to remove unused variables to improve the redability of the code and avoid being into some nasty logical issues in the code */ Runtime Errors (Exceptions) - Program Crash These are the errors you will encounter during the runtime of the program. You will be able to compile the code successfully, but during the runtime of the program due to not handling some specific condition, you may end up with a program crash! (crash due to an exception). These bugs are harder to detect compared to the compile-time errors since the compiler will not help you to spot them. But fixing some warnings may help you to mitigate some of these nasty runtime issues. gdb debugger can be used to debug the run time errors most of the time. We strongly recommend you to get your hands on gdb debugger from week 3 onwards when writing code. It is taught in detail in Week 07, but you may refer to the following link for quick tips. Divide by zero is a perfect example of a runtime error. Later, with pointers introduced in week 03, you will encounter a lot of bugs in this category. Example 01 Example 02 int main() { int num1, num2; scanf(\"%d %d\", &amp;num1, &amp;num2); printf(\"Division: %f\", num1 / num2); return 0; } /* This program will successfully compile but will fail in runtime */ int main() { int num1, num2; scanf(\"%d %d\", &amp;num1, &amp;num2); if (num2 != 0) printf(\"Division: %f\", num1 / num2); return 0; } /* This program will successfully compile but will fail in runtime */ Runtime Errors (Logical Bugs) - Unexpected behaviours These are the bugs due to your logic being wrong. No compilation errors, no runtime crashes (hopefully), but your program does not provide the expected output. Hence, your program will show unexpected behaviour where you expect something else. These are worst nightmare grade bugs and there is no way to detect them unless you review the logic of the code from A-Z. gdb debugger can be used to some extent to figure out where the logical bug is, but depending on your experience in coding, it will take few minutes to few hours and few days to troubleshoot the logical bug. The more you code, the more you gain in coding experience so keep it up! Example 01 Example 02 int main() { int num1, num2; scanf(\"%d %d\", num1, num2); printf(\"Addition: %d\", num1 - num2); return 0; } /* This program will successfully compile, no runtime-crashes, but logically wrong! */ /* Addition does not add two number but taking the difference. Therefore, you need to fix the logic of the code. */ int main() { int num1, num2; scanf(\"%d %d\", num1, num2); printf(\"Addition: %d\", num1 + num2); /* FIXED */ return 0; } FAQ 1. What are variable declarations, definitions, initializations, assignments, function declarations, definitions, invocations? What other terminology is there in C programming? Please refer to the “Glossary” in Blackboard for the terminology that you need to be aware of in C programming. Getting the right terminology is very important in UCP to understand the advanced concepts of C programming in the later weeks. So make sure you know the terms right! 2. What happens if a variable is declared but not initialized? Any implications? During variable declaration, the variable will be allocated memory depending on the variable type (In a 64-bit O/S, int - 32 bits, float - 32 bits, double - 64 bits, etc). Since the variable is not initialized, the value it would contain is the value that already exists in the location where the memory is allocated. This is some random garbage value. 3. Do I need to know function recursion? I’m not from a programming background, but I do have a fair bit of understanding of programming constructs such as if, while, etc. I find it difficult to understand function recursion to perform the lab practical? is it really necessary? No, it’s not mandatory to know function recursion as long as you know the control structures such as if, while, do-while well in C programming. Function recursion is an alternate way to perform certain tasks easier and faster than writing a while loop. 4. Difference between int main() and void main() Like any other function, main is also a function but with a special characteristic that the program execution always starts from the ‘main’. ‘int’ and ‘void’ are its return type. So, let’s discuss all of the three one by one. void main – The ANSI standard says “no” to the ‘void main’ and thus using it can be considered wrong. One should stop using the ‘void main’ if doing so. int main – ‘int main’ means that our function needs to return some integer at the end of the execution and we do so by returning 0 at the end of the program. 0 is the standard for the “successful execution of the program”. This is an indication to the underlying O/S which in fact calls the entry point (main() function) in your program. main – In C89, the unspecified return type defaults to int. So, the main is equivalent to int main in C89. But in C99, this is not allowed and thus one must use int main. So, the preferred way is int main. 5. What are %d, %c, etc symbols? Those are called format specifiers for printf and scanf functions in C. Acts as a place holder and will be replaced with the actual value of the variable when used in printf(…). You will learn more about it in “Arrays and Strings” Lecture. int num = 10; pritnf(\"%d\", num); /* num is an integer */ Some of the format specifiers are: %d - int (same as %i) %ld - long int (same as %li) %lu - long unsinged int %f - float %lf , %g - double %c - char %s - string %x - hexadecimal Reference: C Programming/Simple input and output Also, refer to “Input / Output” lecture for more details. 6. What happens if the user inputs a character when an integer (%d) is expected? Basically, it will not set the character to the integer variable. The variable will be left untouched. Therefore it is important to use the correct placeholder (format specifier) for the right input data type. Example 01 Example 02 int num = 0; /* Initialize the variable to 0 */ scanf(\"%d\", &amp;num); /* if user inputs character 'A' */ print(\"%d\", num); /* num will still be 0 */ int num; /* num contains some garbage value = 42098 */ scanf(\"%d\", &amp;num); /* if user inputs character 'A' */ print(\"%d\", num); /* num will still be 42098 */ 7. Why do we need to use &amp;variable_name in scanf but not in printf? Variable has 4 important parts. Memory allocation (depends on the variable type) Memory address where the memory allocation is Name (alias to refer to the allocated memory) Value &amp; sign will fetch the memory address of a variable given the variable name. Since scanf stores a value from the user in a variable, it needs to know the actual memory address of the variable to locate the location in the memory. int num; char ch; scanf(\"%d\", &amp;num); scanf(\" %c\", &amp;ch); /* make sure to keep a space \" %c\" to consume all the whitespaces preeding the user input character. In contrast, \"%d\" consumes all whitespaces by default. Ref: https://eecs.wsu.edu/~cs150/reading/scanf.htm */ Input and the scanf function i.e. Ask for int: buffer: 1\\n int is read %d buffer: \\n ask for char buffer: \\na\\n read char or string, \\n is read buffer: a\\n (left in buffer)"
  }}
